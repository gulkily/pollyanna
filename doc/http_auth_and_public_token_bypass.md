# HTTP Authentication and Public Token Bypass Documentation

## Overview

This document explains how HTTP authentication works in the Pollyanna system and provides implementation guidance for a public token bypass feature that allows items with a "public" token to bypass HTTP authentication requirements.

## Current HTTP Authentication Implementation

### Multi-Server Support

Pollyanna supports multiple web servers with HTTP authentication:

1. **Apache/HTTPD** - Using .htaccess files
2. **Lighttpd** - Using configuration files
3. **PHP Built-in Server** - Via route handling

### Apache HTTP Auth (htaccess)

**Template Location**: `/default/template/htaccess/htaccess_htpasswd.template`

```apache
AuthName "it_will_show_as_stars"
AuthType Basic
AuthUserFile .htpasswd
SetEnvIfNoCase Cookie "test=1" PASS
Require valid-user
Order Deny,Allow
Deny from all
Allow from env=PASS
Satisfy any
```

**Key Features:**
- Uses HTTP Basic Authentication
- Password file: `.htpasswd` (generated by `/default/template/perl/script/htpasswd.pl`)
- **Cookie bypass mechanism already exists**: `SetEnvIfNoCase Cookie "test=1" PASS`
- Uses `Satisfy any` to allow either valid credentials OR cookie bypass

### Lighttpd HTTP Auth

**Template Location**: `/default/template/lighttpd/lighttpd_basic_auth.conf.template`

```lighttpd
server.modules += (
    "mod_auth",       # basic auth
    "mod_authn_file", # needed for basic auth file
    "mod_access"      # allows blocking by ip address
)

auth.backend = "plain"
auth.backend.plain.userfile = "config/lighttpd/lighttpd_password.conf"
auth.require = (
    "/" => (
        "method"  => "basic",
        "realm" => "it_will_show_as_stars",
        "require" => "valid-user"
    )
)
```

### PHP Route Handler

**Location**: `/default/template/php/route.php`

The PHP route handler processes requests and can implement auth checks through the routing system.

## Token System Integration

### Current Token Framework

**Location**: `/default/template/perl/token_defs.pl`

The system already has a robust token parsing system that processes various tokens found in items and applies them as attributes. Tokens are stored in the `item_attribute` table with the following schema:

```sql
CREATE TABLE item_attribute (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    file_hash,
    attribute,
    value,
    epoch,
    source
);
```

### Token Processing

Tokens are processed during content indexing and can:
- Apply to the item itself (`apply_to_self`)
- Apply to parent items (`apply_to_parent`) 
- Apply to top-level thread items (`apply_to_thread`)

## Proposed Public Token Bypass Implementation

### 1. Add Public Token Definition

Add to `/default/template/perl/token_defs.pl`:

```perl
{
    'token' => 'public',
    'mask' => '^(public)(\W*)()$',
    'mask_params' => 'mgi',
    'message' => '[Public]',
    'apply_to_self' => 1,
    'apply_to_parent' => 1
},
```

### 2. Public Item List Generator Script

**Create**: `/default/template/perl/script/generate_public_list.pl`

```perl
#!/usr/bin/perl -T

use strict;
use warnings;
use 5.010;
use utf8;

$ENV{PATH} = "/bin:/usr/bin";

require_once('utils.pl');
require_once('config.pl');
require_once('database.pl');

sub GeneratePublicItemList {
    WriteLog('GeneratePublicItemList() begin');
    
    my $query = '
        SELECT DISTINCT 
            item_attribute.file_hash,
            item.file_path
        FROM item_attribute 
        LEFT JOIN item ON (item_attribute.file_hash = item.file_hash)
        WHERE item_attribute.attribute = "public"
        ORDER BY item_attribute.file_hash
    ';
    
    my @queryResult = SqliteQueryHashRef($query);
    
    my $publicListDir = GetDir('config') . '/public';
    if (!-d $publicListDir) {
        mkdir($publicListDir) or WriteLog("Failed to create $publicListDir: $!");
    }
    
    # Generate hash list file
    my $hashListFile = $publicListDir . '/item_hash_list.txt';
    open(my $hashFh, '>', $hashListFile) or die "Cannot open $hashListFile: $!";
    
    # Generate URL pattern file for web servers
    my $urlListFile = $publicListDir . '/url_patterns.txt';
    open(my $urlFh, '>', $urlListFile) or die "Cannot open $urlListFile: $!";
    
    my $count = 0;
    for my $row (@queryResult) {
        my $fileHash = $row->{'file_hash'};
        my $filePath = $row->{'file_path'};
        
        if ($fileHash && IsItem($fileHash)) {
            print $hashFh "$fileHash\n";
            
            # Generate common URL patterns for this item
            print $urlFh "/item/$fileHash\n";
            print $urlFh "/read/$fileHash\n";
            print $urlFh "/thread/$fileHash\n";
            
            # Add short hash patterns (first 8 chars)
            my $shortHash = substr($fileHash, 0, 8);
            print $urlFh "/item/$shortHash\n";
            print $urlFh "/read/$shortHash\n";
            
            $count++;
        }
    }
    
    close($hashFh);
    close($urlFh);
    
    # Generate timestamp file
    my $timestampFile = $publicListDir . '/last_updated.txt';
    open(my $tsFh, '>', $timestampFile) or die "Cannot open $timestampFile: $!";
    print $tsFh time() . "\n";
    close($tsFh);
    
    WriteLog("GeneratePublicItemList() completed: $count public items found");
    return $count;
} # GeneratePublicItemList()

sub GetPublicItemCount {
    my $publicListDir = GetDir('config') . '/public';
    my $hashListFile = $publicListDir . '/item_hash_list.txt';
    
    if (!-f $hashListFile) {
        return 0;
    }
    
    my $count = 0;
    open(my $fh, '<', $hashListFile) or return 0;
    while (<$fh>) {
        $count++ if /^[0-9a-f]{40}$/;
    }
    close($fh);
    
    return $count;
} # GetPublicItemCount()

sub IsItemPublicFromList { # $fileHash ; Returns 1 if item is in public list
    my $fileHash = shift;
    
    if (!IsItem($fileHash)) {
        return 0;
    }
    
    my $publicListDir = GetDir('config') . '/public';
    my $hashListFile = $publicListDir . '/item_hash_list.txt';
    
    if (!-f $hashListFile) {
        WriteLog('IsItemPublicFromList: public list not found, regenerating...');
        GeneratePublicItemList();
    }
    
    # Simple file-based lookup for performance
    open(my $fh, '<', $hashListFile) or return 0;
    while (my $line = <$fh>) {
        chomp $line;
        if ($line eq $fileHash) {
            close($fh);
            return 1;
        }
    }
    close($fh);
    
    return 0;
} # IsItemPublicFromList()

# Command line interface
if (@ARGV) {
    my $command = $ARGV[0];
    
    if ($command eq 'generate' || $command eq 'update') {
        my $count = GeneratePublicItemList();
        print "Generated public item list with $count items\n";
    }
    elsif ($command eq 'count') {
        my $count = GetPublicItemCount();
        print "Public items: $count\n";
    }
    elsif ($command eq 'check') {
        my $itemHash = $ARGV[1];
        if ($itemHash) {
            my $isPublic = IsItemPublicFromList($itemHash);
            print $isPublic ? "public\n" : "private\n";
        } else {
            print "Usage: $0 check <item_hash>\n";
        }
    }
    else {
        print "Usage: $0 {generate|count|check <hash>}\n";
    }
} else {
    print "Usage: $0 {generate|count|check <hash>}\n";
}

1;
```

### 3. Database Helper Functions (Optional)

Add to `/default/template/perl/database.pl` for compatibility:

```perl
sub DBIsItemPublic { # $fileHash ; Returns 1 if item has public token
    # Use pre-built list for performance
    return IsItemPublicFromList(shift);
} # DBIsItemPublic()

sub DBGetPublicItemCount {
    # Use pre-built list for performance  
    return GetPublicItemCount();
} # DBGetPublicItemCount()
```

### 4. Apache Implementation

**Create**: `/default/template/htaccess/htaccess_public_auth.template`

```apache
AuthName "it_will_show_as_stars"
AuthType Basic
AuthUserFile .htpasswd

# Existing cookie bypass
SetEnvIfNoCase Cookie "test=1" PASS

# Public item URL bypass using static file
# Check if requested URL matches any in public URL patterns
SetEnvIfNoCase Request_URI "^/item/[0-9a-f]{8}" CHECK_PUBLIC
SetEnvIfNoCase Request_URI "^/item/[0-9a-f]{40}" CHECK_PUBLIC  
SetEnvIfNoCase Request_URI "^/read/[0-9a-f]{8}" CHECK_PUBLIC
SetEnvIfNoCase Request_URI "^/read/[0-9a-f]{40}" CHECK_PUBLIC
SetEnvIfNoCase Request_URI "^/thread/[0-9a-f]{8}" CHECK_PUBLIC
SetEnvIfNoCase Request_URI "^/thread/[0-9a-f]{40}" CHECK_PUBLIC

# Use RewriteMap to check against public URL list
RewriteEngine On
RewriteMap publicurls txt:/config/public/url_patterns.txt
RewriteCond ${publicurls:%{REQUEST_URI}|NOT_FOUND} !NOT_FOUND
RewriteRule .* - [E=PASS:1]

Require valid-user
Order Deny,Allow
Deny from all
Allow from env=PASS
Satisfy any
```

### 5. Lighttpd Implementation

**Create**: `/default/template/lighttpd/lighttpd_public_auth.conf.template`

```lighttpd
server.modules += (
    "mod_auth",
    "mod_authn_file", 
    "mod_access"
)

auth.backend = "plain"
auth.backend.plain.userfile = "config/lighttpd/lighttpd_password.conf"

# Load public URL patterns from file
# Note: This requires mod_magnet or external script to read file
# Simplified approach: use URL patterns directly

# Public item patterns - no auth required
$HTTP["url"] =~ "^/(item|read|thread)/[0-9a-f]{8,40}$" {
    # Check if URL is in public list via external script
    $HTTP["url"] !~ "PLACEHOLDER_FOR_NON_PUBLIC_PATTERNS" {
        auth.require = ()  # No auth required
    }
}

# Default: require auth for all other URLs
$HTTP["url"] !~ "^/(item|read|thread)/[0-9a-f]{8,40}$" {
    auth.require = (
        "/" => (
            "method"  => "basic",
            "realm" => "it_will_show_as_stars",
            "require" => "valid-user"
        )
    )
}
```

**Note**: Lighttpd implementation can be enhanced with mod_magnet for dynamic file reading.

### 6. PHP Implementation

**Modify**: `/default/template/php/route.php`

Add near the beginning of the file:

```php
function CheckPublicItemBypass() {
    $requestUri = $_SERVER['REQUEST_URI'] ?? '';
    
    // Extract item hash from URL patterns
    $patterns = [
        '/\/item\/([a-f0-9]{8,40})/',
        '/\/read\/([a-f0-9]{8,40})/', 
        '/\/thread\/([a-f0-9]{8,40})/'
    ];
    
    foreach ($patterns as $pattern) {
        if (preg_match($pattern, $requestUri, $matches)) {
            $itemHash = $matches[1];
            
            // Extend short hash to full hash if needed
            if (strlen($itemHash) == 8) {
                $itemHash = GetFullHashFromShort($itemHash);
            }
            
            if ($itemHash && IsItemPublicFromList($itemHash)) {
                // Set bypass cookie
                setcookie('publicitem', '1', time() + 3600, '/');
                return true;
            }
        }
    }
    
    return false;
}

// Add to utils.php
function IsItemPublicFromList($fileHash) {
    $publicListFile = GetDir('config') . '/public/item_hash_list.txt';
    
    if (!file_exists($publicListFile)) {
        WriteLog('IsItemPublicFromList: public list not found');
        return false;
    }
    
    // Read public item list
    $publicItems = file($publicListFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
    
    if (!$publicItems) {
        return false;
    }
    
    return in_array($fileHash, $publicItems, true);
}

function GetFullHashFromShort($shortHash) {
    // Query database to find full hash from short hash
    $query = "SELECT file_hash FROM item WHERE file_hash LIKE ? LIMIT 1";
    $result = SqliteGetValue($query, [$shortHash . '%']);
    return $result ?: false;
}

// Call the check early in request processing
if (CheckPublicItemBypass()) {
    WriteLog('Public item bypass activated for: ' . $_SERVER['REQUEST_URI']);
}
```

### 7. Build System Integration

**Modify**: `/default/template/perl/build.pl`

Add function to regenerate public list during build:

```perl
sub UpdatePublicItemList {
    WriteLog('UpdatePublicItemList() begin');
    
    if (GetConfig('setting/admin/public_bypass_enable')) {
        require_once('script/generate_public_list.pl');
        my $count = GeneratePublicItemList();
        WriteLog("Updated public item list: $count items");
        
        # Trigger web server config regeneration if needed
        if ($count > 0) {
            TouchFile(GetDir('config') . '/public/.htaccess_needs_update');
        }
    }
} # UpdatePublicItemList()
```

### 8. Hike.sh Integration

**Modify**: `/hike.sh`

Add command for managing public item lists:

```bash
# Add to hike.sh command handling
public)
    case "$2" in
        generate|update)
            echo "Generating public item list..."
            perl default/template/perl/script/generate_public_list.pl generate
            ;;
        count)
            perl default/template/perl/script/generate_public_list.pl count
            ;;
        check)
            if [ -n "$3" ]; then
                perl default/template/perl/script/generate_public_list.pl check "$3"
            else
                echo "Usage: $0 public check <item_hash>"
            fi
            ;;
        *)
            echo "Usage: $0 public {generate|count|check <hash>}"
            ;;
    esac
    ;;
```

### 9. Configuration Settings

Add configuration files:

**Create**: `/default/setting/admin/public_bypass_enable`
```
0
```

**Create**: `/default/setting/admin/public_bypass_cookie_duration`
```
3600
```

**Create**: `/default/setting/admin/public_bypass_auto_update`
```
1
```

### 10. Security Considerations

1. **File Permissions**: Ensure public list files are readable but not writable by web server
2. **Token Validation**: Only properly formatted "public" tokens are recognized via existing token system
3. **Scope Limiting**: Public bypass only applies to item/read/thread URLs, not admin pages
4. **Rate Limiting**: Consider file-based rate limiting for public access
5. **Logging**: All public access attempts are logged via existing WriteLog system
6. **Path Traversal Protection**: File paths are sanitized through existing GetDir() function

## Revised Implementation Steps

1. **Add public token definition** to `token_defs.pl` (5 minutes)
2. **Create public list generator script** `generate_public_list.pl` (30 minutes)
3. **Add build system integration** to `build.pl` (15 minutes)  
4. **Add hike.sh command interface** (10 minutes)
5. **Create configuration settings** (5 minutes)
6. **Update Apache htaccess template** for RewriteMap support (30 minutes)
7. **Update PHP route.php** for file-based lookup (30 minutes)
8. **Add Lighttpd configuration** template (20 minutes)
9. **Testing and validation** (60 minutes)

**Total Estimated Time**: ~3.5 hours

## Testing Strategy

1. **Create test items** with "public" token
2. **Verify token parsing** and database storage
3. **Test each web server configuration**:
   - Access public items without auth
   - Verify non-public items still require auth
   - Test with and without existing cookie bypass
4. **Performance testing** for database lookup overhead
5. **Security testing** for bypass attempt validation

## Revised Complexity Assessment

### ðŸŸ¢ **LOW COMPLEXITY** (Total: ~1 hour)
1. **Token Definition** - 5 minutes (simple addition)
2. **Configuration Settings** - 5 minutes (standard files)
3. **Hike.sh Integration** - 10 minutes (command wrapper)
4. **Build System Integration** - 15 minutes (function call)
5. **Basic Testing** - 25 minutes (smoke tests)

### ðŸŸ¡ **MEDIUM COMPLEXITY** (Total: ~2 hours)  
1. **Perl Generator Script** - 30 minutes (database query + file I/O)
2. **PHP Implementation** - 30 minutes (file reading + URL parsing)
3. **Apache htaccess** - 30 minutes (RewriteMap configuration)
4. **Lighttpd Configuration** - 20 minutes (conditional auth setup)
5. **Comprehensive Testing** - 30 minutes (multi-server validation)

### ðŸ”´ **HIGH COMPLEXITY** (Total: ~30 minutes)
1. **Advanced Lighttpd Features** - 30 minutes (mod_magnet integration if needed)

## Performance Benefits of Pre-built Approach

1. **No Runtime Database Queries** - Static file lookup vs SQL query per request
2. **Web Server Native Optimizations** - Apache RewriteMap, Lighttpd file operations
3. **Caching Friendly** - File system caching, CDN compatibility
4. **Scalable** - O(1) file lookup vs O(log n) database query

## Updated Effort Estimation

| Component | Original Estimate | Revised Estimate | Reduction |
|-----------|------------------|------------------|-----------|
| Token & DB | 2-3 hours | 30 minutes | -75% |
| Core Script | 6-8 hours | 30 minutes | -90% |
| Apache Support | 4-6 hours | 30 minutes | -85% |
| Lighttpd Support | 12-16 hours | 20 minutes | -95% |
| PHP Support | 4-6 hours | 30 minutes | -85% |
| Testing | 8-10 hours | 60 minutes | -85% |
| **Total** | **32-43 hours** | **~3.5 hours** | **-90%** |

## Key Improvements

1. **Eliminated Runtime Complexity** - No Lua scripting, no database calls per request
2. **Leveraged Existing Patterns** - Uses established file-based configuration approach
3. **Simplified Web Server Configs** - Static file operations vs dynamic processing
4. **Reduced Dependencies** - No additional modules required
5. **Better Performance** - File system lookups vs database queries

## Implementation Risk Assessment

| Risk | Original | Revised | Mitigation |
|------|----------|---------|------------|
| Performance Impact | HIGH | LOW | Pre-built static files |
| Complex Config | HIGH | LOW | Standard file operations |
| Multi-server Support | HIGH | MEDIUM | Simplified configurations |
| Race Conditions | MEDIUM | LOW | File-based, atomic updates |
| Maintenance Overhead | HIGH | LOW | On-demand regeneration |

## Backward Compatibility

This implementation maintains full backward compatibility:
- Existing authentication mechanisms continue to work unchanged
- Cookie bypass (`test=1`) remains fully functional  
- No changes to existing item behavior unless public token is present
- Feature can be completely disabled via configuration
- No database schema changes required
- Web server configurations are additive, not replacement

## Multi-Language Support

The token system is language-agnostic since tokens are processed during indexing phase by Perl scripts, regardless of which web server/language serves the content. The public bypass logic leverages:

- **Perl** (for build-time list generation)
- **Static Files** (for runtime lookups)
- **Web Server Native Features** (RewriteMap, conditional auth)
- **Standard File I/O** (cross-platform compatibility)

## Recommended Implementation Order

1. **Phase 1** (30 minutes): Token definition + generator script + basic testing
2. **Phase 2** (60 minutes): PHP implementation + Apache support + integration testing  
3. **Phase 3** (30 minutes): Lighttpd support + comprehensive testing
4. **Phase 4** (60 minutes): Build system integration + hike.sh commands + documentation

**Total**: 3 hours for full implementation across all supported platforms.